One of my all-time favorite game shows is Who Wants to be a Millionaire? While I could not recreate the glamour of the lights and the overall atmosphere of the real-life experience, I had wished to create a fun coding gadget that closely emulates the game. Since the purpose of this assignment implement a social issue construct into the overall purpose of the code, I chose to focus my efforts on climate change (and more specifically the atmospheric level of carbon dioxide measured in parts per million or ppm for short). While climate change and environmental issues are not my main focus when it comes to my civic engagement efforts outside of class, I still feel that this is an important topic and one that should not be overlooked or dismissed. The intention of this game – outside from having fun – is to act as an educational tool for all participants to learn about this important issue that can and has plagued the world.

As per the game itself, participants start with a lethal level of 65,000 ppm of carbon dioxide and must work their wake towards the healthy/normal level of 250 ppm of CO2. Whereas the original Who Wants to be a Millionaire starts with a low value and ends at a high value, this code-based version acts as a reverse. This is to suggest that when one first starts the game, they may have a great lack of knowledge that could greatly impede the health and cleanliness of our environment and that learning more could for instance relieve the amount of CO2 in the atmosphere. You may have notice that after answering all questions correctly, the total ppm never reaches a healthy level of 250. That is to assert that it is not enough to know these answers, but that one must also inform others about this topic and attempt to actively change their/others’ behavior(s). For a more detailed explanation of the side effects of each ppm level, please visit - https://www.kane.co.uk/knowledge-centre/what-are-safe-levels-of-co-and-co2-in-rooms

The game includes a total of 14 questions and provides the opportunity to use the three lifelines (ask a friend, ask the audience and 50/50). For the ask a friend lifeline, the top two choices and bottom two choices will be randomly switched to insure that using the lifeline will not always provide the correct answer. The nice additional aspect about this lifeline is that the participant will be provided with the opportunity of choosing a friend from a list of three friends with randomized information (different occupations from a list of occupations - https://foxhugh.com/word-lists-for-esl/ ; different male names from a list of males names - https://www.babble.com/pregnancy/1000-most-popular-boy-names/ ; different female names from a list of female names - https://www.verywellfamily.com/top-1000-baby-girl-names-2757832 ; and different ages from a range of 25 to 95). If a friend is over the age of 70, a retired label is attached to their occupation variable. Each list of three friends will have different names, different occupations, different ages and at least one of every gender. What the participant does not know is that it does not matter which friend is chosen because they would all provide the same responses in terms of their top choice, second choice, third choice and worst choice). That is to suggest that anyone (all genders, ages and occupations/educational levels) can and should know about this important issue topic. The ask the audience lifeline will provide randomly generated percentage (adding up to 100) with the likelihood (but not certainty) that the correct response will receive the highest level of percentage, followed by the second-best response and so on. Finally, the 50/50 lifeline will provide only the top two responses to choose from written in alphabetical order based on the randomized order that is generated when the question is first asked.

One of the main limitations of this code (and one that I could have fixed if I had more time) was the fact that the lifelines could be used one per round. In the real game show, a participant can only use a lifeline per game (not per round). In addition, I did not make it possible to use multiple lifelines in a round. For this game, I would have also loved to add music and a countdown clock (showcasing the amount of time left that a person has left to answer a question). It would have also been nice to implement tkinter for the ppm bank and the usage of the lifelines (to show how many lifelines are left and to enable the participant to simply click on a lifeline in order to utilize it). After conducting research on tkinter and trying it out for myself, I found it very difficult to master – particularly in such a short time provided for this game. Finally, I tried to implement the lists described above by importing the hyperlinks to my file, but I continuously received an error suggesting that the file was not saved in the correct directory even though it clearly was.

Throughout the development of this project, I improved significantly as a coder. By the end of the code, I managed to learn and successfully implement the various facets of random (randrange, sample, choice, shuffle – which returns a none type so I did not end up using this for my code, etc.) I learned more about threading and its varied intricacies which includes the fact that a thread could only be started once. I learned about the time.sleep function which adds a countdown of seconds that does not enable the next line to start until the countdown expires. I experimented with the collections.namedtuple functionality which could potentially save a few lines as opposed to utilizing a class. I also successfully implemented a class which was a concept that I had great difficulty with in the past. I learned how to iterate through while loops using a break, a pass or continue and how to successfully implement returned statements (whether exact variables or lists) using indexes of tuples. I also learned about the index function which finds the index of an item within a list (particularly helpful if the items are randomly generated).

Other concepts that I did not use for the code but that I also got to experiment with and for the most part master were try/except/finally, the zip function and the pop function (which we touched on in class). The functions were in the end not useful for me and part of the reason for that was because I did not fully master all of their functionalities and uses. With this in mind, I had most importantly learned that I know very little about coding and that there is so much more to learn in python and other languages.
